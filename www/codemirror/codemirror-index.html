<!DOCTYPE html>
<html>

<head>
  <meta charset=utf8>
  <meta name="viewport" id="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
  <script src="resources/lib/codemirror/lib/codemirror.js"></script>
  <link rel="stylesheet" type="text/css" href="resources/lib/codemirror/lib/codemirror.css">
  <script src="resources/mode/mediawiki/mediawiki.js"></script>
  <link rel="stylesheet" type="text/css" href="resources/mode/mediawiki/mediawiki.css">
  <link rel="stylesheet" type="text/css" href="codemirror-common.css">
  <link rel="stylesheet" id="codemirror-theme" type="text/css" href="">

  <script>
    const applyTheme = (themeName) => {
      document.getElementById('codemirror-theme').setAttribute('href', `codemirror-${themeName}.css`)  
    }
    document.addEventListener('DOMContentLoaded', () => {
      const params = (new URL(window.location)).searchParams
      applyTheme(params.get('theme'))
    })
  </script>

</head>


<body>

  <!--TODO: load config by lang as needed-->
  <script>
  let config
  </script>
  <script src="codemirror-config.js" ></script>


  <script>

    let editor
    
    let codeMirrorSettings = {
      mwConfig: config,
      lineWrapping: true,
      lineNumbers: true,
      mode: "text/mediawiki",
      matchBrackets: true,
      extraKeys: {
        // t.b.d.
      }, 
      inputStyle: 'contenteditable',
      spellcheck: false,
      viewportMargin: Infinity
    }

    const rangesIntersect = (range1, range2) => {
      if (range1.start > range2.start + (range2.end - range2.start)) return false
      if (range2.start > range1.start + (range1.end - range1.start)) return false
      return true
    }

    const getSelectionRange = (doc) => {
      const fromCursor = doc.getCursor('from')
      const toCursor = doc.getCursor('to')
      return {
        start: fromCursor.ch,
        end: toCursor.ch,
        isSingleLine: (fromCursor.line === toCursor.line),
        line: fromCursor.line
      }
    }
    
    const tokensIntersectingSelection = (selectionRange, lineTokens) => {
      return lineTokens
        .filter(token => {
          return rangesIntersect(selectionRange, token)
        })
    }

    const buttonPayload = (buttonName, buttonInfoDict) => {
      return {button: buttonName, info: buttonInfoDict}
    } 

    // returns zero if `string` is not comprised only of `char`.
    // else returns length of `string`
    const charCountInString = (string, char) => {
      const matches = string.match(`^${char}+$`)
      return (matches === null) ? 0 : string.length
    }

    const numberFromPrefixedKey = (array, prefix) => {
      const s = array.find(s => s.startsWith(prefix))
      if (!s) {
        return null
      }
      return parseInt(s.substring(prefix.length))
    }

    // The wikitext parser doesn't add a useful classes for some wikitext constructs, so supplement 
    // these here. Makes it easier to determine when the cursor sits in such wikitext (or it's
    // selected) with the same mechanism (token 'type' inspection).
    const enrichedLineTokens = (doc, line) => {
      const lineTokens = doc.getLineTokens(line, true)

      enrichHeadingTokens(lineTokens)      
      enrichListTokens(lineTokens)
      enrichIndentTokens(lineTokens)
      enrichSignatureTokens(lineTokens)
      
      return lineTokens
    }

    const tokenIncludesType = (token, type) => {
      return (token.type === null) ? false : token.type.split(' ').includes(type)
    }

    const indexOfFirstLineTokenWithType = (lineTokens, type) => {
      return lineTokens.findIndex(token => {
        return tokenIncludesType(token, type)
      })
    }

    // Adds missing classes to heading contents.
    const enrichHeadingTokens = (lineTokens) => {
      const headingTokenIndex = indexOfFirstLineTokenWithType(lineTokens, 'mw-section-header')
      const headingContentsTokenIndex = headingTokenIndex + 1
      const headingContentsTokenExists = headingContentsTokenIndex <= (lineTokens.length - 1)
      if (headingTokenIndex < 0 || !headingContentsTokenExists) {
        return
      }
      const headingToken = lineTokens[headingTokenIndex]
      const headingContentsToken = lineTokens[headingContentsTokenIndex]
      if (headingToken.end === headingContentsToken.start) {
        addTypeToToken(headingContentsToken, 'mw-section-header-text')
        addTypeToToken(headingContentsToken, `mw-section-header-depth-${headingContentsToken.start}`)
      }
    }

    const addTypeToToken = (token, type) => {
      if (token.type === null) {
        token.type = type
      } else {
        let types = token.type.split(' ')
        types.push(type)
        token.type = types.join(' ')
      }
    }

    const lineTokensFromTokenAtIndex = (lineTokens, index) => {
      return lineTokens.filter((token, thisIndex) => thisIndex >= index)
    }
    
    const enrichListTokens = (lineTokens) => {
      const soughtTokenIndex = indexOfFirstLineTokenWithType(lineTokens, 'mw-list')
      if (soughtTokenIndex < 0) {
        return
      }      
      const soughtToken = lineTokens[soughtTokenIndex]
      const supplementToken = (token) => {
        addTypeToToken(token, `mw-list-depth-${soughtToken.end}`)
        addTypeToToken(token, soughtToken.string.includes('#') ? `mw-list-ordered` : `mw-list-unordered`)
      }
      lineTokensFromTokenAtIndex(lineTokens, soughtTokenIndex)
        .forEach(supplementToken)
    }

    const enrichIndentTokens = (lineTokens) => {
      const soughtTokenIndex = indexOfFirstLineTokenWithType(lineTokens, 'mw-indenting')
      if (soughtTokenIndex < 0) {
        return
      }      
      const soughtToken = lineTokens[soughtTokenIndex]
      const supplementToken = (token, index) => {
        if (index > 0) {
          addTypeToToken(token, `mw-indenting-contents`)
        }
        addTypeToToken(token, `mw-indenting-depth-${soughtToken.end}`)
      }
      lineTokensFromTokenAtIndex(lineTokens, soughtTokenIndex)
        .forEach(supplementToken)
    }

    const enrichSignatureTokens = (lineTokens) => {
      const supplementToken = (token) => {
        addTypeToToken(token, `mw-signature-depth-${token.end - token.start}`)
      }
      lineTokens
        .filter(token => {
          return tokenIncludesType(token, 'mw-signature')
        })
        .forEach(supplementToken)
    }

    const selectedButtons = (doc) => {  
      const selection = doc.getSelection()
      const multipleCharactersSelected = selection.length > 0
      const selectionRange = getSelectionRange(doc)
      const lineTokens = enrichedLineTokens(doc, selectionRange.line)
      
      // For now only supports single line selection ranges.
      const intersectingTokens = selectionRange.isSingleLine ? tokensIntersectingSelection(selectionRange, lineTokens) : []
      const typesArray = intersectingTokens.map(token => token.type)
        .join(' ')
        .split(' ')
        .filter(s => {
          return s.trim().length > 0
        })
      
      let result = []
      
      if (typesArray.includes('strong')) {
        result.push(buttonPayload('bold'))
      }
      if (typesArray.includes('em')) {
        result.push(buttonPayload('italic'))
      }
      if (typesArray.includes('mw-link-ground')) {
        result.push(buttonPayload('link'))
      }
      if (typesArray.includes('mw-tag-ref') || typesArray.includes('mw-ext-ref')) {
        result.push(buttonPayload('reference'))
      }
      if (typesArray.includes('mw-template-ground')) {
        result.push(buttonPayload('template'))
      }
      if (typesArray.includes('mw-comment')) {
        result.push(buttonPayload('comment'))
      }
      if (typesArray.includes('mw-section-header-text')) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-section-header-depth-')
        result.push(buttonPayload('heading', {depth: depth}))
      }
      if (typesArray.includes('mw-list-ordered') || typesArray.includes('mw-list-unordered')) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-list-depth-')
        const ordered = typesArray.includes('mw-list-ordered')
        result.push(buttonPayload('li', {depth: depth, ordered: ordered}))
      }
      if (typesArray.includes('mw-indenting') || typesArray.includes('mw-indenting-contents')) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-indenting-depth-')
        result.push(buttonPayload('indent', {depth: depth}))
      }
      if (typesArray.includes('mw-signature')/* || typesArray.includes('mw-signature-contents')*/) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-signature-depth-')
        result.push(buttonPayload('signature', {depth: depth}))
      }

      result.push(buttonPayload('debug', {
         tokensIntersectingSelectionStrings: intersectingTokens.map(token => token.string).join(''),
         tokensIntersectingSelectionTypesArray: typesArray,
         selectionRange: getSelectionRange(doc),
         getSelectionText: selection
       }
      ))
     
      const historySize = doc.historySize()
      if (historySize.undo > 1) {
        result.push(buttonPayload('undo'))
      }
      if (historySize.redo > 0) {
        result.push(buttonPayload('redo'))
      }
        
      return result
    }

    const sendNativeMessages = (doc) => {
      // sends message to native land that selection has changed,
      // upon receipt native land should de-select all buttons
      const selectionRange = getSelectionRange(doc)
      const isSelectionMoreThanOneChar = !selectionRange.isSingleLine || (selectionRange.end - selectionRange.start) > 0
      window.webkit.messageHandlers.selectionChanged.postMessage(isSelectionMoreThanOneChar)

      // sends message to native land about which buttons should be selected,
      // native land should assume only these buttons should appear selected
      window.webkit.messageHandlers.highlightTheseButtons.postMessage(selectedButtons(doc))
    }
        
    const setupCodemirror = () => {
      editor = CodeMirror(document.body, codeMirrorSettings)
      editor.on('cursorActivity', sendNativeMessages)
    }
    
    const wrapSelectionWith = (openingMarkup, closingMarkup) => {
      if (closingMarkup === undefined) {
        closingMarkup = openingMarkup
      }
      var selectedText = editor.getSelection()
      if (!selectedText || selectedText.length == 0) {
        selectedText = ' '
      }
      editor.replaceSelection(openingMarkup + selectedText + closingMarkup, 'around')
      const selections = editor.listSelections()
      if (selections.length > 0) {
        const openingMarkupLength = openingMarkup.length
        const closingMarkupLength = closingMarkup.length
        const selection = selections[0]
        const fromPos = selection.from()
        const toPos = selection.to()
        const from = {line: fromPos.line, ch: fromPos.ch + openingMarkupLength, sticky: fromPos.sticky}
        const to = {line: toPos.line, ch: toPos.ch - closingMarkupLength, sticky: toPos.sticky}
        editor.setSelection(from, to)
      }
    }
    
    const reverseString = (string) => {
      return string.split('').reverse().join('')
    }
    
    const unwrapSelectionWith = (openingMarkup, closingMarkup) => {
      if (closingMarkup === undefined) {
        closingMarkup = openingMarkup
      }
      const selections = editor.listSelections()
      if (selections.length > 0) {
        const selection = selections[0]
        const fromPos = selection.from()
        const toPos = selection.to()
        if (fromPos.line != toPos.line || fromPos.ch != toPos.ch) {
          wrapSelectionWith(openingMarkup, closingMarkup)
          return
        }
        const lineIndex = fromPos.line
        const line = editor.getLine(lineIndex)
        const before = line.substring(0, fromPos.ch)
        const after = line.substring(fromPos.ch, line.length)
        const adjustedBefore = reverseString(reverseString(before).replace(reverseString(openingMarkup), ''))
        const adjustedAfter = after.replace(closingMarkup, '')
        const adjustedLine = adjustedBefore + adjustedAfter
        if (line.length != adjustedLine.length) {
          editor.replaceRange(adjustedLine, {line: lineIndex, ch: 0}, {line: lineIndex, ch: line.length})
          const openingMarkupLength = openingMarkup.length
          const from = {line: fromPos.line, ch: fromPos.ch - openingMarkupLength, sticky: fromPos.sticky}
          const to = {line: toPos.line, ch: toPos.ch - openingMarkupLength, sticky: toPos.sticky}
          editor.setSelection(from, to)
        }
      }
    }
    
    const isButtonSelected = (buttonType) => selectedButtons(editor).filter((item) => {return item.button === buttonType}).length > 0
    
    const toggleMarkup = (button, openingMarkup, closingMarkup) => {
      const isSelected = isButtonSelected(button)
      if (isSelected) {
        unwrapSelectionWith(openingMarkup, closingMarkup)
      } else {
        wrapSelectionWith(openingMarkup, closingMarkup)
      }
    }
    
    const wmf = {}
    
    wmf.getWikitext = () => editor.getValue()
    wmf.setWikitext = (wikitext) => editor.setValue(wikitext)
    wmf.setup = () => setupCodemirror()
    wmf.applyTheme = (themeName) => applyTheme(themeName)

    wmf.commands = {
      focus: () => {
        editor.focus()
      },
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      cursorUp: () => editor.execCommand('goLineUp'),
      cursorDown: () => editor.execCommand('goLineDown'),
      cursorLeft: () => editor.execCommand('goCharLeft'),
      cursorRight: () => editor.execCommand('goCharRight'),
      bold: () => {
        toggleMarkup('bold', "'''")
      },
      italic: () => {
        toggleMarkup('italic', "''")
      },
      reference: () => {
        toggleMarkup('reference', '<ref>', '</ref>')
      },
      template: () => {
        toggleMarkup('template', '{{', '}}')
      },
      anchor: () => {
        toggleMarkup('anchor', '[[', ']]')
      },
      comment: () => {
        toggleMarkup('comment', '<!--', '-->')
      },
      indent: () => {
        console.log('indent')
      },
      signature: () => {
        console.log('signature')
      },
      unorderedList: () => {
        // toggleMarkup('list', 'UUU')
      },
      orderedList: () => {
        // toggleMarkup('list', 'OOO')
      },
      superscript: () => {
        // TODO: determine 'superscript' in selectedButtons
        toggleMarkup('superscript', '<sup>', '</sup>')
      },
      subscript: () => {
        // TODO: determine 'subscript' in selectedButtons
        toggleMarkup('subscript', '<sub>', '</sub>')
      },
      underline: () => {
        // TODO: determine 'underline' in selectedButtons
        toggleMarkup('underline', '<u>', '</u>')
      },
      strikethrough: () => {
        // TODO: determine 'strikethrough' in selectedButtons
        toggleMarkup('strikethrough', '<s>', '</s>')
      },
      heading: () => {
        console.log('heading')
      },
      increaseIndentDepth: () => {
        console.log('increaseIndentDepth')
      },
      decreaseIndentDepth: () => {
        console.log('decreaseIndentDepth')
      },
      normalTextSize: () => {
        // TODO: remove either small or big tags
        console.log('normalTextSize')
      },
      smallTextSize: () => {
        // TODO: determine 'small' in selectedButtons
        toggleMarkup('small', '<small>', '</small>')
      },
      bigTextSize: () => {
        // TODO: determine 'big' in selectedButtons
        toggleMarkup('big', '<big>', '</big>')
      },
      selectAll: () => editor.execCommand('selectAll'),
      highlighting: () => {
        editor.setOption('maxHighlightLength', editor.getOption('maxHighlightLength') === -1 ? 10000 : -1)
        editor.refresh()
      }
    }
    
    window.wmf = wmf

  </script>
</body>

<html>
